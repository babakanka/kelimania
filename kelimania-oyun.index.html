<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeliMania - T√ºrk√ße Kelime Oyunu</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; font-family: system-ui, -apple-system, sans-serif; }
        #root { width: 100%; min-height: 100vh; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
import React, { useState } from 'react';
import { Shuffle, MessageCircle, Play, SkipForward, Trophy, Zap, Loader2, RefreshCw } from 'lucide-react';

const BOARD_SIZE = 15;
const TRIPLE_LETTER = [[3,3],[3,11],[11,3],[11,11]];
const DOUBLE_WORD = [[7,3],[7,11],[3,7],[11,7]];

const POINTS = {
  A:1,B:5,C:6,√á:6,D:4,E:1,F:8,G:5,ƒû:8,H:6,I:5,ƒ∞:5,J:10,K:3,L:3,M:4,
  N:2,O:5,√ñ:7,P:7,R:2,S:4,≈û:6,T:3,U:4,√ú:6,V:7,Y:4,Z:6
};

const LETTERS = ['A','B','C','√á','D','E','F','G','ƒû','H','I','ƒ∞','J','K','L','M','N','O','√ñ','P','R','S','≈û','T','U','√ú','V','Y','Z'];

// TDK S√∂zl√ºk API - Netlify Backend Kullanƒ±mƒ±
const wordCache = new Map();

const checkWordWithTDK = async (word) => {
  const normalized = word.toUpperCase().trim();
  
  if (normalized.length < 2) {
    return false;
  }
  
  console.log('üîç Kelime kontrol:', normalized);
  
  // Cache kontrol√º
  if (wordCache.has(normalized)) {
    const result = wordCache.get(normalized);
    console.log('üíæ Cache:', normalized, result ? '‚úÖ' : '‚ùå');
    return result;
  }
  
  try {
    // NETLIFY BACKEND API
    const apiUrl = `https://kaleidoscopic-bienenstitch-3cb160.netlify.app/.netlify/functions/check?word=${encodeURIComponent(normalized)}`;
    
    console.log('üåê Backend API √ßaƒürƒ±sƒ±:', apiUrl);
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    
    const response = await fetch(apiUrl, {
      method: 'GET',
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      console.error('‚ùå API hatasƒ±:', response.status);
      wordCache.set(normalized, false);
      return false;
    }
    
    const data = await response.json();
    console.log('üì¶ API yanƒ±tƒ±:', data);
    
    const isValid = data.valid === true;
    
    console.log(isValid ? '‚úÖ GE√áERLƒ∞' : '‚ùå GE√áERSƒ∞Z', normalized);
    
    wordCache.set(normalized, isValid);
    return isValid;
    
  } catch (error) {
    console.error('üí• Hata:', error.message);
    wordCache.set(normalized, false);
    return false;
  }
};

const Game = () => {
  const initBag = () => {
    const newBag = [];
    LETTERS.forEach(l => { 
      for(let i=0; i<3; i++) newBag.push(l);
    });
    for(let i=0; i<3; i++) newBag.push('*');
    return newBag.sort(() => Math.random()-0.5);
  };

  const ensureVowels = (hand) => {
    const vowels = ['A', 'E', 'I', 'ƒ∞', 'O', '√ñ', 'U', '√ú'];
    const vowelCount = hand.filter(l => vowels.includes(l)).length;
    
    if(vowelCount >= 2) return hand;
    
    const newHand = [...hand];
    const needed = 2 - vowelCount;
    
    const consonantIndices = [];
    newHand.forEach((l, i) => {
      if(!vowels.includes(l) && l !== '*') {
        consonantIndices.push(i);
      }
    });
    
    const shuffledConsonants = consonantIndices.sort(() => Math.random() - 0.5);
    for(let i = 0; i < needed && i < shuffledConsonants.length; i++) {
      const randomVowel = vowels[Math.floor(Math.random() * vowels.length)];
      newHand[shuffledConsonants[i]] = randomVowel;
    }
    
    return newHand;
  };

  const initialBag = initBag();
  const rawP1Hand = initialBag.slice(0,7);
  const rawP2Hand = initialBag.slice(7,14);
  
  const [board, setBoard] = useState(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)));
  const [bag, setBag] = useState(initialBag.slice(14));
  const [p1Hand, setP1Hand] = useState(ensureVowels(rawP1Hand));
  const [p2Hand, setP2Hand] = useState(ensureVowels(rawP2Hand));
  const [turn, setTurn] = useState(1);
  const [p1Score, setP1Score] = useState(0);
  const [p2Score, setP2Score] = useState(0);
  const [temp, setTemp] = useState([]);
  const p1Color = '#ef4444';
  const p2Color = '#eab308';
  const [msg, setMsg] = useState('');
  const [dragLetter, setDragLetter] = useState(null);
  const [dragBoard, setDragBoard] = useState(null);
  const [p1Pass, setP1Pass] = useState(0);
  const [p2Pass, setP2Pass] = useState(0);
  const [over, setOver] = useState(false);
  const [win, setWin] = useState(null);
  const [chat, setChat] = useState(false);
  const [msgs, setMsgs] = useState([]);
  const [chatTxt, setChatTxt] = useState('');
  const [checking, setChecking] = useState(false);
  const [wordPreview, setWordPreview] = useState({ valid: [], invalid: [] });
  const [swapMode, setSwapMode] = useState(false);
  const [selSwap, setSelSwap] = useState([]);
  const [showJokerModal, setShowJokerModal] = useState(false);
  const [jokerIdx, setJokerIdx] = useState(null);

  const getBonus = (r,c) => {
    if(TRIPLE_LETTER.some(([x,y])=>x===r&&y===c)) return '3xH';
    if(DOUBLE_WORD.some(([x,y])=>x===r&&y===c)) return '2xK';
    return null;
  };

  const isValid = (r,c,color) => {
    if(board[r][c]) return false;
    if(temp.find(t=>t.r===r&&t.c===c)) return false;
    
    const directNeighbors = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
    for(const [nr,nc] of directNeighbors) {
      if(nr<0||nr>=BOARD_SIZE||nc<0||nc>=BOARD_SIZE) continue;
      
      const n = board[nr][nc];
      if(n && n.color!==color) {
        console.log('‚ùå Rakip karoya kom≈üu olamaz:', {r,c}, 'Rakip:', {nr,nc});
        return false;
      }
      
      const nt = temp.find(t=>t.r===nr&&t.c===nc);
      if(nt && nt.color!==color) {
        console.log('‚ùå Rakip ge√ßici karoya kom≈üu olamaz:', {r,c}, 'Rakip:', {nr,nc});
        return false;
      }
    }
    return true;
  };

  const calcArea = () => {
    let p1=0, p2=0;
    for(let r=0; r<BOARD_SIZE; r++) {
      for(let c=0; c<BOARD_SIZE; c++) {
        if(board[r][c]) {
          if(board[r][c].color===p1Color) p1++;
          else if(board[r][c].color===p2Color) p2++;
        }
      }
    }
    temp.forEach(t => {
      if(t.color===p1Color) p1++;
      else if(t.color===p2Color) p2++;
    });
    const total = BOARD_SIZE * BOARD_SIZE;
    return {
      p1: ((p1/total)*100).toFixed(1), 
      p2: ((p2/total)*100).toFixed(1)
    };
  };

  const findWordsWithTemp = (tempTiles) => {
    const words = [];
    const tb = board.map(r=>[...r]);
    tempTiles.forEach(t => { tb[t.r][t.c] = {letter:t.letter,isNew:true}; });
    
    for(let r=0; r<BOARD_SIZE; r++) {
      let w='',hn=false;
      for(let c=0; c<BOARD_SIZE; c++) {
        if(tb[r][c]) { 
          w+=tb[r][c].letter; 
          if(tb[r][c].isNew) hn=true; 
        } else { 
          if(w.length>=2&&hn) words.push(w); 
          w=''; hn=false; 
        }
      }
      if(w.length>=2&&hn) words.push(w);
    }
    
    for(let c=0; c<BOARD_SIZE; c++) {
      let w='',hn=false;
      for(let r=0; r<BOARD_SIZE; r++) {
        if(tb[r][c]) { 
          w+=tb[r][c].letter; 
          if(tb[r][c].isNew) hn=true; 
        } else { 
          if(w.length>=2&&hn) words.push(w); 
          w=''; hn=false; 
        }
      }
      if(w.length>=2&&hn) words.push(w);
    }
    
    if(words.length===0 && tempTiles.length>0) {
      words.push(tempTiles.map(t=>t.letter).join(''));
    }
    
    return [...new Set(words)];
  };

  const validateWords = async (words) => {
    const results = await Promise.all(
      words.map(async (word) => ({
        word,
        valid: await checkWordWithTDK(word)
      }))
    );
    return results;
  };

  const checkWords = async (tempTiles) => {
    if (tempTiles.length === 0) {
      setWordPreview({ valid: [], invalid: [] });
      return;
    }
    
    const words = findWordsWithTemp(tempTiles);
    const results = await validateWords(words);
    
    const valid = results.filter(r => r.valid).map(r => r.word);
    const invalid = results.filter(r => !r.valid).map(r => r.word);
    
    setWordPreview({ valid, invalid });
  };

  const calcScoreForTemp = (tempTiles) => {
    let base=0,mult=1;
    tempTiles.forEach(t => {
      let pts = POINTS[t.letter]||0;
      if(TRIPLE_LETTER.some(([x,y])=>x===t.r&&y===t.c)&&!board[t.r][t.c]) pts*=3;
      if(DOUBLE_WORD.some(([x,y])=>x===t.r&&y===t.c)&&!board[t.r][t.c]) mult*=2;
      base+=pts;
    });
    let sc = base*mult;
    if(tempTiles.length===7) sc*=2;
    return sc;
  };

  const clickCell = (r,c) => {
    if(swapMode) return;
    const exist = temp.find(t=>t.r===r&&t.c===c);
    if(exist) { 
      const newTemp = temp.filter(t=>!(t.r===r&&t.c===c));
      setTemp(newTemp);
      checkWords(newTemp);
      return;
    }
    if(board[r][c]) return;
    const color = turn===1?p1Color:p2Color;
    if(!isValid(r,c,color)) { 
      setMsg('‚ö†Ô∏è Rakibe √ßok yakƒ±n!'); 
      setTimeout(()=>setMsg(''),2000);
      return; 
    }
    if(dragLetter) {
      const newTemp = [...temp,{r,c,letter:dragLetter.letter,idx:dragLetter.idx,color,isJoker:dragLetter.isJoker||false}];
      setTemp(newTemp);
      checkWords(newTemp);
      setDragLetter(null);
    }
  };

  const handleDragStart = (e,l,i) => {
    if(temp.some(t=>t.idx===i)) { e.preventDefault(); return; }
    if(l==='*') { 
      e.preventDefault();
      setJokerIdx(i);
      setShowJokerModal(true);
      return; 
    }
    setDragLetter({letter:l,idx:i});
  };

  const handleBoardDrag = (e,r,c) => {
    const p = temp.find(t=>t.r===r&&t.c===c);
    if(!p) { e.preventDefault(); return; }
    setDragBoard({...p,oldR:r,oldC:c});
  };

  const handleDrop = (e,r,c) => {
    e.preventDefault();
    const color = turn===1?p1Color:p2Color;
    
    if(dragBoard) {
      if(board[r][c]) return;
      if(!isValid(r,c,color)) { setDragBoard(null); return; }
      const nt = temp.filter(t=>!(t.r===dragBoard.oldR&&t.c===dragBoard.oldC));
      nt.push({r,c,letter:dragBoard.letter,idx:dragBoard.idx,color:dragBoard.color,isJoker:dragBoard.isJoker});
      setTemp(nt);
      checkWords(nt);
      setDragBoard(null);
      return;
    }
    
    if(dragLetter) {
      if(board[r][c]) return;
      if(!isValid(r,c,color)) { setDragLetter(null); return; }
      if(temp.find(t=>t.r===r&&t.c===c)) return;
      const newTemp = [...temp,{r,c,letter:dragLetter.letter,idx:dragLetter.idx,color,isJoker:dragLetter.isJoker||false}];
      setTemp(newTemp);
      checkWords(newTemp);
      setDragLetter(null);
    }
  };

  const confirm = async () => {
    if(temp.length===0) return;
    
    setChecking(true);
    setMsg('üîç Kelimeler kontrol ediliyor...');
    
    try {
      const words = findWordsWithTemp(temp);
      const results = await validateWords(words);
      
      const invalid = results.filter(r => !r.valid);
      
      if(invalid.length > 0) {
        setMsg('‚ùå Ge√ßersiz kelime: ' + invalid.map(r => r.word).join(', '));
        setChecking(false);
        setTimeout(() => setMsg(''), 3000);
        return;
      }
      
      const nb = board.map(r=>[...r]);
      temp.forEach(t => { nb[t.r][t.c]={letter:t.letter,color:t.color,isJoker:t.isJoker}; });
      setBoard(nb);
      
      const sc = calcScoreForTemp(temp);
      const validWords = results.map(r => r.word).join(', ');
      
      if(temp.length===7) {
        setMsg('üéâ COMBO x2! ' + validWords + ' (+' + sc + ')');
      } else {
        setMsg('‚úÖ ' + validWords + ' (+' + sc + ')');
      }
      
      setTimeout(() => setMsg(''), 4000);
      
      const used = temp.map(t=>t.idx);
      const hand = turn===1 ? p1Hand : p2Hand;
      const newHand = hand.filter((_,i)=>!used.includes(i));
      
      const refill = bag.slice(0, used.length);
      const newBag = bag.slice(used.length);
      const finalHand = ensureVowels([...newHand, ...refill]);
      
      if(turn===1) { 
        setP1Score(p1Score+sc); 
        setP1Hand(finalHand);
        setP1Pass(0);
      } else { 
        setP2Score(p2Score+sc); 
        setP2Hand(finalHand);
        setP2Pass(0);
      }
      
      setBag(newBag);
      setTemp([]);
      setWordPreview({ valid: [], invalid: [] });
      setTurn(turn===1?2:1);
      
      if(newBag.length === 0 && finalHand.length === 0) {
        setOver(true);
        setWin(p1Score+sc > p2Score ? 1 : (p2Score+sc > p1Score+sc ? 2 : 0));
      }
      
    } catch (error) {
      setMsg('‚ùå Hata olu≈ütu: ' + error.message);
      setTimeout(() => setMsg(''), 3000);
    }
    
    setChecking(false);
  };

  const pass = () => {
    if(turn===1) {
      setP1Pass(p1Pass+1);
      if(p1Pass+1 >= 3) {
        setOver(true);
        setWin(p2Score > p1Score ? 2 : (p1Score > p2Score ? 1 : 0));
        return;
      }
    } else {
      setP2Pass(p2Pass+1);
      if(p2Pass+1 >= 3) {
        setOver(true);
        setWin(p1Score > p2Score ? 1 : (p2Score > p1Score ? 2 : 0));
        return;
      }
    }
    setTemp([]);
    setWordPreview({ valid: [], invalid: [] });
    setMsg('');
    setTurn(turn===1?2:1);
  };

  const shuffle = () => {
    const hand = turn===1 ? p1Hand : p2Hand;
    const shuffled = [...hand].sort(() => Math.random()-0.5);
    if(turn===1) setP1Hand(shuffled);
    else setP2Hand(shuffled);
  };

  const swapLetters = () => {
    if(selSwap.length === 0) {
      setMsg('‚ö†Ô∏è Deƒüi≈ütirilecek harf se√ßin!');
      setTimeout(() => setMsg(''), 2000);
      return;
    }
    
    if(bag.length < selSwap.length) {
      setMsg('‚ö†Ô∏è √áantada yeterli harf yok!');
      setTimeout(() => setMsg(''), 2000);
      return;
    }
    
    const hand = turn === 1 ? p1Hand : p2Hand;
    const newHand = hand.filter((_, i) => !selSwap.includes(i));
    const newLetters = bag.slice(0, selSwap.length);
    const newBag = [...bag.slice(selSwap.length), ...hand.filter((_, i) => selSwap.includes(i))];
    
    const finalHand = [...newHand, ...newLetters];
    
    if(turn === 1) {
      setP1Hand(finalHand);
    } else {
      setP2Hand(finalHand);
    }
    
    setBag(newBag);
    setSelSwap([]);
    setSwapMode(false);
    setTemp([]);
    setWordPreview({ valid: [], invalid: [] });
    setTurn(turn === 1 ? 2 : 1);
    setMsg('‚úì Harfler deƒüi≈ütirildi');
    setTimeout(() => setMsg(''), 2000);
  };

  const toggleSwapMode = () => {
    if(temp.length > 0) {
      setMsg('‚ö†Ô∏è √ñnce tahtadaki harfleri geri alƒ±n!');
      setTimeout(() => setMsg(''), 2000);
      return;
    }
    setSwapMode(!swapMode);
    setSelSwap([]);
    if(!swapMode) {
      setMsg('üìù Deƒüi≈ütirilecek harfleri se√ßin');
    } else {
      setMsg('');
    }
  };

  const currentHand = turn===1 ? p1Hand : p2Hand;
  const areaStats = calcArea();

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Header - Side by Side Score Bars */}
        <div className="mb-2">
          <div className="flex gap-2 max-w-md mx-auto">
            <div className={`flex-1 flex items-center justify-between px-2 py-1.5 rounded-lg ${turn===1?'bg-red-500':'bg-red-400/50'} text-white text-sm`}>
              <div className="flex items-center gap-1.5">
                <div className="w-5 h-5 bg-white rounded-full flex items-center justify-center text-red-500 font-bold text-xs">1</div>
                <span className="font-bold">{p1Score}</span>
              </div>
              <div className="text-xs">
                <span>%{areaStats.p1}</span>
                {p1Pass>0 && <span className="ml-1">({p1Pass})</span>}
              </div>
            </div>
            
            <div className={`flex-1 flex items-center justify-between px-2 py-1.5 rounded-lg ${turn===2?'bg-yellow-500':'bg-yellow-400/50'} text-white text-sm`}>
              <div className="flex items-center gap-1.5">
                <div className="w-5 h-5 bg-white rounded-full flex items-center justify-center text-yellow-600 font-bold text-xs">2</div>
                <span className="font-bold">{p2Score}</span>
              </div>
              <div className="text-xs">
                <span>%{areaStats.p2}</span>
                {p2Pass>0 && <span className="ml-1">({p2Pass})</span>}
              </div>
            </div>
          </div>
          <div className="text-white text-center mt-1 text-xs opacity-80">√áanta: {bag.length}</div>
        </div>

        {/* Message */}
        {msg && (
          <div className="text-center mb-4">
            <div className="inline-block bg-white px-6 py-3 rounded-lg shadow-lg text-lg font-bold">
              {checking && <Loader2 className="inline mr-2 animate-spin" size={20} />}
              {msg}
            </div>
          </div>
        )}

        {/* Game Over */}
        {over && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-md">
              <Trophy className="w-20 h-20 mx-auto text-yellow-500 mb-4" />
              <h2 className="text-3xl font-bold mb-4">Oyun Bitti!</h2>
              {win===0 ? (
                <p className="text-xl mb-4">Berabere! ü§ù</p>
              ) : (
                <p className="text-xl mb-4">Oyuncu {win} Kazandƒ±! üéâ</p>
              )}
              <div className="text-lg mb-6">
                <div>Oyuncu 1: {p1Score} puan</div>
                <div>Oyuncu 2: {p2Score} puan</div>
              </div>
              <button 
                onClick={() => window.location.reload()} 
                className="bg-purple-600 text-white px-6 py-3 rounded-lg font-bold hover:bg-purple-700"
              >
                Yeni Oyun
              </button>
            </div>
          </div>
        )}

        <div className="flex gap-2 flex-wrap justify-center items-start">
          {/* Board - LARGE 15x15 Grid */}
          <div className="bg-white p-2 rounded-lg shadow-2xl" style={{width: 'min(95vw, 800px)'}}>
            <div className="grid gap-px" style={{gridTemplateColumns:`repeat(${BOARD_SIZE}, minmax(0, 1fr))`}}>
              {board.map((row,r)=>row.map((cell,c)=>{
                const tempTile = temp.find(t=>t.r===r&&t.c===c);
                const bonus = getBonus(r,c);
                return (
                  <div 
                    key={`${r}-${c}`}
                    onClick={()=>clickCell(r,c)}
                    onDrop={(e)=>handleDrop(e,r,c)}
                    onDragOver={(e)=>e.preventDefault()}
                    draggable={tempTile?true:false}
                    onDragStart={(e)=>handleBoardDrag(e,r,c)}
                    className={`aspect-square w-full flex items-center justify-center border border-gray-300 cursor-pointer font-bold text-sm md:text-base lg:text-lg relative
                      ${cell ? '' : bonus==='3xH' ? 'bg-blue-300' : bonus==='2xK' ? 'bg-pink-300' : 'bg-amber-50'}
                      ${tempTile ? 'ring-1 ring-green-500' : ''}
                      hover:brightness-95 transition-all active:scale-95`}
                    style={{backgroundColor: cell?.color || tempTile?.color}}
                  >
                    {tempTile ? (
                      <span className="text-white drop-shadow font-bold">
                        {tempTile.letter}
                        {tempTile.isJoker && <span className="text-[10px]">‚òÖ</span>}
                      </span>
                    ) : cell ? (
                      <span className="text-white drop-shadow font-bold">
                        {cell.letter}
                        {cell.isJoker && <span className="text-[10px]">‚òÖ</span>}
                      </span>
                    ) : bonus ? (
                      <span className="text-[9px] md:text-[10px] text-gray-600 font-semibold">{bonus}</span>
                    ) : null}
                  </div>
                );
              }))}
            </div>
          </div>

          {/* Controls - Mini Compact */}
          <div className="space-y-1.5 w-full sm:w-auto sm:max-w-[200px]">
            {/* Hand */}
            <div className="bg-white p-1.5 rounded-lg shadow">
              <div className="flex gap-1 flex-wrap justify-center">
                {currentHand.map((letter,idx)=>{
                  const used = temp.some(t=>t.idx===idx);
                  const selected = selSwap.includes(idx);
                  const isJokerCard = letter === '*';
                  const jokerInPlay = temp.find(t => t.idx === idx && t.isJoker);
                  
                  return (
                    <div 
                      key={idx}
                      draggable={!used && !swapMode}
                      onDragStart={(e)=>handleDragStart(e,letter,idx)}
                      onClick={() => {
                        if(swapMode && !used) {
                          if(selected) {
                            setSelSwap(selSwap.filter(i => i !== idx));
                          } else {
                            setSelSwap([...selSwap, idx]);
                          }
                        } else if(isJokerCard && !used) {
                          setJokerIdx(idx);
                          setShowJokerModal(true);
                        }
                      }}
                      className={`w-10 h-10 sm:w-11 sm:h-11 flex flex-col items-center justify-center border-2 rounded font-bold text-sm relative
                        ${used ? 'opacity-30 cursor-not-allowed border-gray-300 bg-gray-100' : 
                          swapMode ? (selected ? 'border-orange-500 bg-orange-200 cursor-pointer' : 'border-gray-400 bg-yellow-100 cursor-pointer') :
                          isJokerCard ? 'border-purple-500 bg-gradient-to-br from-purple-100 to-pink-200 hover:scale-105 cursor-pointer active:scale-95' :
                          'border-purple-400 bg-gradient-to-br from-yellow-100 to-yellow-200 hover:scale-105 cursor-move active:scale-95'}
                        transition-transform shadow-sm`}
                    >
                      <span className="text-xs sm:text-sm">{jokerInPlay ? jokerInPlay.letter : letter}</span>
                      {letter!=='*' && <span className="text-[8px] text-gray-600">{POINTS[letter]}</span>}
                      {isJokerCard && !used && <span className="text-[9px] text-purple-600 absolute bottom-0">‚≠ê</span>}
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Buttons */}
            <div className="flex flex-col gap-1">
              {(wordPreview.valid.length > 0 || wordPreview.invalid.length > 0) && (
                <div className="bg-white p-1 rounded text-[10px]">
                  {wordPreview.valid.length > 0 && (
                    <div>
                      <span className="text-green-600">‚úì</span>
                      <span className="ml-0.5">{wordPreview.valid.join(',')}</span>
                      <span className="ml-0.5 text-gray-600">(+{calcScoreForTemp(temp)})</span>
                    </div>
                  )}
                  {wordPreview.invalid.length > 0 && (
                    <div>
                      <span className="text-red-600">‚úó</span>
                      <span className="ml-0.5">{wordPreview.invalid.join(',')}</span>
                    </div>
                  )}
                </div>
              )}

              {swapMode ? (
                <div className="flex gap-1">
                  <button 
                    onClick={swapLetters}
                    disabled={selSwap.length === 0}
                    className="flex-1 bg-orange-500 text-white p-1.5 rounded flex items-center justify-center hover:bg-orange-600 disabled:opacity-50 shadow-sm active:scale-95"
                  >
                    <RefreshCw size={12} className="mr-1" />
                    <span className="text-[10px] font-bold">Deƒüi≈ütir</span>
                  </button>
                  <button 
                    onClick={toggleSwapMode}
                    className="flex-1 bg-gray-500 text-white p-1.5 rounded flex items-center justify-center hover:bg-gray-600 shadow-sm active:scale-95"
                  >
                    <span className="text-base mr-1">‚úï</span>
                    <span className="text-[10px] font-bold">ƒ∞ptal</span>
                  </button>
                </div>
              ) : (
                <>
                  <button 
                    onClick={confirm} 
                    disabled={temp.length===0 || checking || wordPreview.invalid.length > 0}
                    className="bg-green-600 text-white p-2 rounded flex items-center justify-center hover:bg-green-700 disabled:opacity-50 shadow-lg active:scale-95"
                  >
                    {checking ? (
                      <><Loader2 className="animate-spin w-4 h-4 mr-1" /><span className="text-xs">Kontrol...</span></>
                    ) : (
                      <><Play size={16} fill="white" className="mr-1" /><span className="text-xs font-bold">Oyna</span></>
                    )}
                  </button>
                  
                  {temp.length > 0 && wordPreview.invalid.length > 0 && (
                    <div className="bg-red-100 text-red-700 px-1 py-0.5 rounded text-[9px] text-center">‚ö†Ô∏è</div>
                  )}
                  
                  <div className="grid grid-cols-4 gap-1">
                    <button 
                      onClick={() => {
                        setTemp([]);
                        setWordPreview({ valid: [], invalid: [] });
                        setMsg('');
                      }}
                      disabled={temp.length === 0}
                      className="bg-red-500 text-white p-1.5 rounded flex flex-col items-center justify-center hover:bg-red-600 disabled:opacity-50 shadow-sm active:scale-95"
                    >
                      <span className="text-lg leading-none mb-0.5">‚Ü∂</span>
                      <span className="text-[8px] leading-none">Geri</span>
                    </button>

                    <button 
                      onClick={shuffle}
                      disabled={temp.length > 0}
                      className="bg-blue-500 text-white p-1.5 rounded flex flex-col items-center justify-center hover:bg-blue-600 disabled:opacity-50 shadow-sm active:scale-95"
                    >
                      <Shuffle size={14} className="mb-0.5" />
                      <span className="text-[8px] leading-none">Karƒ±≈ütƒ±r</span>
                    </button>
                    
                    <button 
                      onClick={toggleSwapMode}
                      disabled={temp.length > 0}
                      className="bg-orange-500 text-white p-1.5 rounded flex flex-col items-center justify-center hover:bg-orange-600 disabled:opacity-50 shadow-sm active:scale-95"
                    >
                      <RefreshCw size={14} className="mb-0.5" />
                      <span className="text-[8px] leading-none">Deƒüi≈ütir</span>
                    </button>

                    <button 
                      onClick={pass}
                      className="bg-gray-500 text-white p-1.5 rounded flex flex-col items-center justify-center hover:bg-gray-600 shadow-sm active:scale-95"
                    >
                      <SkipForward size={14} className="mb-0.5" />
                      <span className="text-[8px] leading-none">Pas</span>
                    </button>
                  </div>

                  <div className="grid grid-cols-2 gap-1">
                    <button 
                      onClick={()=>setChat(!chat)}
                      className="bg-purple-500 text-white p-1.5 rounded flex items-center justify-center hover:bg-purple-600 shadow-sm active:scale-95"
                    >
                      <MessageCircle size={14} className="mr-1" />
                      <span className="text-xs font-bold">Sohbet</span>
                      {msgs.length > 0 && <span className="ml-1 text-[9px]">({msgs.length})</span>}
                    </button>

                    <button 
                      onClick={() => {
                        if(window.confirm(`Oyuncu ${turn} pes ediyor. Oyuncu ${turn===1?2:1} kazanacak. Emin misiniz?`)) {
                          setOver(true);
                          setWin(turn===1?2:1);
                          setMsg(`üè≥Ô∏è Oyuncu ${turn} pes etti!`);
                        }
                      }}
                      className="bg-red-700 text-white p-1.5 rounded flex items-center justify-center hover:bg-red-800 shadow-sm active:scale-95"
                    >
                      <span className="text-lg mr-1">üè≥Ô∏è</span>
                      <span className="text-xs font-bold">Pes Et</span>
                    </button>
                  </div>
                </>
              )}
            </div>
          </div>
        </div>

        {/* Chat */}
        {chat && (
          <div className="mt-6 bg-white p-4 rounded-xl shadow-lg max-w-md mx-auto">
            <div className="text-center font-bold mb-2 text-purple-900">üí¨ Sohbet</div>
            <div className="h-40 overflow-y-auto mb-2 border border-gray-300 rounded p-2 space-y-1 bg-gray-50">
              {msgs.map((m,i)=>(
                <div key={i} className={`text-sm ${m.player===1?'text-red-600':'text-yellow-600'} font-semibold`}>
                  <span>Oyuncu {m.player}:</span> <span className="font-normal">{m.text}</span>
                </div>
              ))}
            </div>
            <div className="flex gap-2">
              <input 
                value={chatTxt} 
                onChange={(e)=>setChatTxt(e.target.value)}
                onKeyPress={(e)=>{if(e.key==='Enter'&&chatTxt.trim()){setMsgs([...msgs,{player:turn,text:chatTxt}]);setChatTxt('');}}}
                className="flex-1 border border-gray-300 rounded px-3 py-2" 
                placeholder="Mesaj yaz..." 
              />
              <button 
                onClick={()=>{if(chatTxt.trim()){setMsgs([...msgs,{player:turn,text:chatTxt}]);setChatTxt('');}}} 
                className="bg-purple-600 text-white px-4 py-2 rounded font-bold text-sm hover:bg-purple-700"
              >
                G√∂nder
              </button>
            </div>
          </div>
        )}

        {/* Joker Modal */}
        {showJokerModal && (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6">
              <h2 className="text-2xl font-bold text-center mb-4 text-purple-900">
                ‚≠ê Joker Harf Se√ßin
              </h2>
              <p className="text-center text-gray-600 mb-6">
                Joker yerine kullanmak istediƒüiniz harfi se√ßin
              </p>
              <div className="grid grid-cols-5 gap-3 mb-6">
                {LETTERS.map((letter) => (
                  <button
                    key={letter}
                    onClick={() => {
                      setDragLetter({letter: letter, idx: jokerIdx, isJoker: true});
                      setShowJokerModal(false);
                    }}
                    className="aspect-square bg-gradient-to-br from-yellow-200 to-yellow-300 hover:from-yellow-300 hover:to-yellow-400 rounded-lg font-bold text-2xl flex items-center justify-center border-2 border-yellow-400 hover:border-yellow-500 transition-all hover:scale-110 shadow-md"
                  >
                    {letter}
                  </button>
                ))}
              </div>
              <button
                onClick={() => {
                  setShowJokerModal(false);
                  setJokerIdx(null);
                }}
                className="w-full bg-gray-500 text-white py-3 rounded-lg font-bold hover:bg-gray-600"
              >
                ƒ∞ptal
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default Game;


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Game />);
    </script>
</body>
</html>